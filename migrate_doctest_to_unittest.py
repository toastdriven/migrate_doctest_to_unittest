#!/usr/bin/env python
"""
In Django-land, unittests are much faster than doctests. Convert them.

Run this as a command without arguments for usage.
"""
import os
import re
import sys


__author__ = "Daniel Lindsley"
__version__ = (0, 3)
__license__ = "BSD"


def main(doc_filename, unit_filename=None):
    if not check_exists(doc_filename):
        raise IOError("The doctest file '%s' does not exist." % doc_filename)
    
    if unit_filename is None:
        unit_filename = os.path.join(os.path.dirname(doc_filename), "views.py")
    
    if check_exists(unit_filename):
        raise IOError("The unittest file '%s' already exists." % unit_filename)
    
    print "Loading doctest file '%s'..." % (doc_filename,),
    loaded_data = load_doctest(doc_filename)
    print "[OK]"
    
    print "Converting the tests...",
    converted_data = convert(loaded_data)
    print "[OK]"
    
    print "Dumping to unittest file '%s'..." % (unit_filename,),
    dump_unittest(unit_filename, converted_data)
    print "[OK]"


def check_exists(filename):
    if os.path.exists(filename):
        return True
    
    return False


def load_doctest(doc_filename):
    doc_file = open(doc_filename, 'r')
    loaded_data = doc_file.readlines()
    doc_file.close()
    return loaded_data


def convert(loaded_data):
    new_data = []
    lines_to_remove = []
    
    new_data.append('# PLEASE EDIT THIS FILE MANUALLY. IT WAS GENERATED BY A PROGRAM. :)\n')
    new_data.append('from django.test import TestCase\n')
    new_data.append('\n')
    new_data.append('\n')
    new_data.append('# FIXME: Change the name of the test case to avoid collisions.\n')
    new_data.append('class ConvertedTestCase(TestCase):\n')
    
    # Clean the doctest data first.
    for line_number, line in enumerate(loaded_data):
        # Add in the fixtures to the class.
        if line.startswith('__fixtures__'):
            new_data.append('    %s' % line.replace('__', ''))
            new_data.append('\n')
            lines_to_remove.append(line_number)
        
        # Remove the triple quotes
        if line == '"""\n' or line == '__doc__ = """\n':
            lines_to_remove.append(line_number)
    
    for number in lines_to_remove[::-1]:
        del(loaded_data[number])
    
    new_data.append('    def test_converted(self):\n')
    object_regex = re.compile('<(\w+): (.*?)>')
    
    # Process the remainder of the file.
    for line_number, line in enumerate(loaded_data):
        cleaned_line = line
        is_assertion = False
        
        if not line.startswith('>>>') and not line.startswith('\n') and not line.startswith('#') and not line.startswith('...'):
            # This doesn't look like code being executed (likely checking output.)
            # We should have read it correctly and plopped it in an assertion with the previous line.
            # Plow ahead.
            continue
        
        if cleaned_line.startswith('>>> from django.test import Client'):
            continue
        
        if cleaned_line.startswith('>>> c = Client()'):
            continue
        
        if 'c.login(' in cleaned_line:
            cleaned_line = cleaned_line.replace('c.login(', 'self.client.login(')
        
        if 'c.logout(' in cleaned_line:
            cleaned_line = cleaned_line.replace('c.logout(', 'self.client.logout(')
        
        # "Look-ahead" to determine if this ought to be an assertion or simply executed.
        try:
            if not loaded_data[line_number + 1].startswith('>>>') and not loaded_data[line_number + 1].startswith('\n') and not loaded_data[line_number + 1].startswith('#') and not loaded_data[line_number + 1].startswith('...'):
                is_assertion = True
        
            cleaned_line = cleaned_line.replace('>>> ', '').replace('... ', '')
            
            # Use the built-in client.
            cleaned_line = cleaned_line.replace('c.get(', 'self.client.get(')
            cleaned_line = cleaned_line.replace('c.post(', 'self.client.post(')
        
            if is_assertion:
                cleaned_line = cleaned_line.rstrip('\n')
                cleaned_assert = loaded_data[line_number + 1].rstrip('\n')
                
                if object_regex.search(cleaned_assert):
                    # Stringify class names.
                    cleaned_assert = object_regex.sub(r"'\2'", cleaned_assert)
                    cleaned_line = "[str(obj) for obj in %s]" % cleaned_line
                    new_data.append('        # FIXME: Had to convert classes to strings. Ensure this looks right.\n')
                    
                cleaned_line = 'self.assertEqual(%s, %s)\n' % (cleaned_line, cleaned_assert)
        except IndexError:
            # We've hit the end.
            pass
            
        new_data.append('        %s' % cleaned_line)
    
    return new_data


def dump_unittest(unit_filename, loaded_data):
    unit_file = open(unit_filename, 'w')
    unit_file.writelines(loaded_data)
    unit_file.close()


if __name__ == '__main__':
    if len(sys.argv) < 2 or len(sys.argv) > 3:
        print "Usage: migrate_doctest_to_unittest.py <doc_filename> [unit_filename]"
        print
        print "If no [unit_filename] is provided, it assumes 'views.py'."
        sys.exit(1)
    
    doc_filename = sys.argv[1]
    unit_filename = None
    
    if len(sys.argv) == 3:
        unit_filename = sys.argv[2]
    
    main(doc_filename, unit_filename)
    print "Migrated successfully."
    print
    print "WARNING: You will want to review the new file, as it is likely to still not be correct and will need manual tweaking."
    print "Also ensure that it checks all the things the previous file did."
    sys.exit()
